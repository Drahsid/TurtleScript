#ifndef T_OPCODE_H
#define T_OPCODE_H

#include "turtleinttypes.h"

// Instruction flags
enum {
    INSTRUCTION_FLAG_IMMEDIATE = (1 << 0),  // Use immediate?
    INSTRUCTION_FLAG_EXTENDED = (1 << 1),   // Is this an extended instruction?
    INSTRUCTION_FLAG_RESERVED0 = (1 << 2),  // Reserved
    INSTRUCTION_FLAG_RESERVED1 = (1 << 3)   // Reserved
};

// Instruction types
enum {
    INSTRUCTION_JB_TYPE = 0b00,     // Jump / Branch
    INSTRUCTION_MEM_TYPE = 0b01,    // Memory operaion
    INSTRUCTION_REG_TYPE = 0b10,    // Register operation
    INSTRUCTION_NO_TYPE = 0b11      // Reserved
};

// JB types
enum {
    /* J    */ INSTRUCTION_JB_JUMP = 0,
    /* JE   */ INSTRUCTION_JB_JUMP_EQUALS,
    /* JG   */ INSTRUCTION_JB_JUMP_GREATER_THAN,
    /* JF   */ INSTRUCTION_JB_JUMP_ON_FLAG,
    /* JAL  */ INSTRUCTION_JB_JUMP_AND_LINK,
    /* JEL  */ INSTRUCTION_JB_JUMP_EQUALS_AND_LINK,
    /* JGL  */ INSTRUCTION_JB_JUMP_GREATER_THAN_AND_LINK,
    /* JFL  */ INSTRUCTION_JB_JUMP_ON_FLAG_AND_LINK,
    /* B    */ INSTRUCTION_JB_BRANCH,
    /* BE   */ INSTRUCTION_JB_BRANCH_EQUALS,
    /* BG   */ INSTRUCTION_JB_BRANCH_GREATER_THAN,
    /* BF   */ INSTRUCTION_JB_BRANCH_ON_FLAG,
               INSTRUCTION_JB_COUNT
};

// MEM types
enum {
    /* S8  */ INSTRUCTION_MEM_STORE_8 = 0,
    /* S16 */ INSTRUCTION_MEM_STORE_16,
    /* S32 */ INSTRUCTION_MEM_STORE_32,
    /* S64 */ INSTRUCTION_MEM_STORE_64,
    /* L8  */ INSTRUCTION_MEM_LOAD_8,
    /* L16 */ INSTRUCTION_MEM_LOAD_16,
    /* L32 */ INSTRUCTION_MEM_LOAD_32,
    /* L64 */ INSTRUCTION_MEM_LOAD_64,
              INSTRUCTION_MEM_COUNT
};

// REG types
enum {
    /* AND  */ INSTRUCTION_REG_AND = 0,
    /* OR   */ INSTRUCTION_REG_OR,
    /* CE   */ INSTRUCTION_REG_COMPARE_EQUALS,
    /* CG   */ INSTRUCTION_REG_COMPARE_GREATER,
    /* ADDU */ INSTRUCTION_REG_ADD_UNSIGNED,
    /* ADD  */ INSTRUCTION_REG_ADD,
    /* MUL  */ INSTRUCTION_REG_MUL,
    /* DIV  */ INSTRUCTION_REG_DIV,
    /* SR   */ INSTRUCTION_REG_SR,
    /* SL   */ INSTRUCTION_REG_SL,
               INSTRUCTION_REG_COUNT
};

// NO types
enum {
    /* NOP  */ INSTRUCTION_NO_TYPE_NOP = 0,
    /* TRAP */ INSTRUCTION_NO_TYPE_TRAP,
               INSTRUCTION_NO_TYPE_COUNT
};

// 0b ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????
#pragma pack(push, 4)
typedef union {
    tu64 dirty;
    struct {
        tu32 type : 2;       // 0b XX?????? ???????? ???????? ???????? ???????? ???????? ???????? ????????
        tu32 index : 4;      // 0b ??XXXX?? ???????? ???????? ???????? ???????? ???????? ???????? ????????
        tu32 flags : 4;      // 0b ??????XX XX?????? ???????? ???????? ???????? ???????? ???????? ????????
        tu32 rs : 5;         // 0b ???????? ???XXXXX ???????? ???????? ???????? ???????? ???????? ????????
        tu32 rl : 5;         // 0b ???????? ???????? XXXXX??? ???????? ???????? ???????? ???????? ????????
        tu32 rr : 5;         // 0b ???????? ???????? ?????XXX XX?????? ???????? ???????? ???????? ????????
        tu32 reserved : 6;   // 0b ???????? ???????? ???????? ??XXXXXX ???????? ???????? ???????? ????????
        tu32 : 0;
        tu32 imm : 32;       // 0b ???????? ???????? ???????? ???????? XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
    };
} TurtleOpcode;

typedef struct {
    TurtleOpcode opcode;
    tu32 imm;
} TurtleOpcode_Extended;
#pragma pack(pop)

extern const char gInstructionMEMNames[INSTRUCTION_MEM_COUNT + 1][16];
extern const char gInstructionMEMNames[INSTRUCTION_MEM_COUNT + 1][16];
extern const char gInstructionREGNames[INSTRUCTION_REG_COUNT + 1][16];
extern const char gInstructionNONames[INSTRUCTION_NO_TYPE_COUNT + 1][16];

extern void Opcode_GetMnemonic(TurtleOpcode_Extended* src, char* out);
extern tu32 Opcode_Assemble(TurtleOpcode_Extended* out, char* src);

#endif

